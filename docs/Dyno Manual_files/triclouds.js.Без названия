THREE.WindowResizer=function(a,b,c,d,e){var f,g,h,k,l,p,q=function(){h=window.innerWidth;k=window.innerHeight;l=h/k;f=c>l?k*c:h;g=c>l?k:h/c;p=1;void 0!==window.devicePixelRatio&&(p=window.devicePixelRatio);a.setSize(f,g);a.setViewport((h-f)/2,-((k-g)/2),f,g);void 0!==d&&d.setSize(f,g);b.aspect=c;b.updateProjectionMatrix();void 0!==e&&e()};window.addEventListener("resize",q,!1);return{trigger:function(){q()},destroy:function(){window.removeEventListener("resize",q)},w:function(){return f},h:function(){return g},
    dpr:function(){return p}}};
(function() {
    var pnoiseChunk = [
        "vec3 mod289(vec3 x)",
        "{",
        "    return x - floor(x * (1.0 / 289.0)) * 289.0;",
        "}",
        "vec4 mod289(vec4 x)",
        "{",
        "    return x - floor(x * (1.0 / 289.0)) * 289.0;",
        "}",
        "vec4 permute(vec4 x)",
        "{",
        "    return mod289(((x * 34.0) + 1.0) * x);",
        "}",
        "vec4 taylorInvSqrt(vec4 r)",
        "{",
        "return 1.79284291400159 - 0.85373472095314 * r;",
        "}",
        "vec3 fade(vec3 t)",
        "{",
        "return t * t * t * (t * (t * 6.0 - 15.0) + 10.0);",
        "}",
        "// Classic Perlin noise, periodic variant",
        "float pnoise(vec3 P, vec3 rep)",
        "{",
        "    vec3 Pi0 = mod(floor(P), rep); // Integer part, modulo period",
        "    vec3 Pi1 = mod(Pi0 + vec3(1.0), rep); // Integer part + 1, mod period",
        "    Pi0 = mod289(Pi0);",
        "    Pi1 = mod289(Pi1);",
        "    vec3 Pf0 = fract(P); // Fractional part for interpolation",
        "    vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0",
        "    vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);",
        "    vec4 iy = vec4(Pi0.yy, Pi1.yy);",
        "    vec4 iz0 = Pi0.zzzz;",
        "    vec4 iz1 = Pi1.zzzz;",
        "    vec4 ixy = permute(permute(ix) + iy);",
        "    vec4 ixy0 = permute(ixy + iz0);",
        "    vec4 ixy1 = permute(ixy + iz1);",
        "    vec4 gx0 = ixy0 * (1.0 / 7.0);",
        "    vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;",
        "    gx0 = fract(gx0);",
        "    vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);",
        "    vec4 sz0 = step(gz0, vec4(0.0));",
        "    gx0 -= sz0 * (step(0.0, gx0) - 0.5);",
        "    gy0 -= sz0 * (step(0.0, gy0) - 0.5);",
        "    vec4 gx1 = ixy1 * (1.0 / 7.0);",
        "    vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;",
        "    gx1 = fract(gx1);",
        "    vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);",
        "    vec4 sz1 = step(gz1, vec4(0.0));",
        "    gx1 -= sz1 * (step(0.0, gx1) - 0.5);",
        "    gy1 -= sz1 * (step(0.0, gy1) - 0.5);",
        "    vec3 g000 = vec3(gx0.x, gy0.x, gz0.x);",
        "    vec3 g100 = vec3(gx0.y, gy0.y, gz0.y);",
        "    vec3 g010 = vec3(gx0.z, gy0.z, gz0.z);",
        "    vec3 g110 = vec3(gx0.w, gy0.w, gz0.w);",
        "    vec3 g001 = vec3(gx1.x, gy1.x, gz1.x);",
        "    vec3 g101 = vec3(gx1.y, gy1.y, gz1.y);",
        "    vec3 g011 = vec3(gx1.z, gy1.z, gz1.z);",
        "    vec3 g111 = vec3(gx1.w, gy1.w, gz1.w);",
        "    vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));",
        "    g000 *= norm0.x;",
        "    g010 *= norm0.y;",
        "    g100 *= norm0.z;",
        "    g110 *= norm0.w;",
        "    vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));",
        "    g001 *= norm1.x;",
        "    g011 *= norm1.y;",
        "    g101 *= norm1.z;",
        "    g111 *= norm1.w;",
        "    float n000 = dot(g000, Pf0);",
        "    float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));",
        "    float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));",
        "    float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));",
        "    float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));",
        "    float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));",
        "    float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));",
        "    float n111 = dot(g111, Pf1);",
        "    vec3 fade_xyz = fade(Pf0);",
        "    vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);",
        "    vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);",
        "    float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x);",
        "    return 2.2 * n_xyz;",
        "}",
        "float turb(vec3 P, float lacunarity, float gain)",
        "{",
        "    float sum = 0.0;",
        "    float scale = 1.0;",
        "    float totalgain = 1.0;",
        "    for (float i = 0.0; i < 6.0; i++)",
        "    {",
        "        sum += totalgain * pnoise(P * scale, vec3(128.0, 128.0, 128.0));",
        "        scale *= lacunarity;",
        "        totalgain *= gain;",
        "    }",
        "    return abs(sum);",
        "}"
    ].join("\n");
    var vertexDeformChunk = [
        "vMovement = vec3(time, time, 0.0226);",
        "vUv = uv;",
        "float noise = turb(vec3(vUv,0.0) + vMovement, 2.0, 0.5);",
        "float displacement = depthSize * noise;",
        "vec4 mvPosition;",
        "mvPosition = modelViewMatrix * vec4( position - normal * displacement, 1.0 );",
        "gl_Position = projectionMatrix * mvPosition;",
        //New Normal Calculations
        "vPosition = gl_Position.xyz;"
    ].join("\n");
    var phongDeformChunk = [
        "vec3 normal = normalize( vNormal );",
        "normal = -normalize(cross(dFdy(vPosition), dFdx(vPosition))); // N is the world normal",
        "vec3 viewPosition = normalize( vViewPosition );",
        "#if MAX_POINT_LIGHTS > 0",
        "	vec3 pointDiffuse  = vec3( 0.0 );",
        "	vec3 pointSpecular = vec3( 0.0 );",
        "	for ( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {",
        "		vec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );",
        "		vec3 lVector = lPosition.xyz + vViewPosition.xyz;",
        "		float lDistance = 1.0;",
        "		if ( pointLightDistance[ i ] > 0.0 )",
        "			lDistance = 1.0 - min( ( length( lVector ) / pointLightDistance[ i ] ), 1.0 );",
        "		lVector = normalize( lVector );",
        // diffuse

        "		float dotProduct = dot( normal, lVector );",
        "		#ifdef WRAP_AROUND",
        "			float pointDiffuseWeightFull = max( dotProduct, 0.0 );",
        "			float pointDiffuseWeightHalf = max( 0.5 * dotProduct + 0.5, 0.0 );",
        "			vec3 pointDiffuseWeight = mix( vec3( pointDiffuseWeightFull ), vec3( pointDiffuseWeightHalf ), wrapRGB );",
        "		#else",
        "			float pointDiffuseWeight = max( dotProduct, 0.0 );",
        "		#endif",
        "		pointDiffuse  += diffuse * pointLightColor[ i ] * pointDiffuseWeight * lDistance;",
        // specular

        "		vec3 pointHalfVector = normalize( lVector + viewPosition );",
        "		float pointDotNormalHalf = max( dot( normal, pointHalfVector ), 0.0 );",
        "		float pointSpecularWeight = specularStrength * max( pow( pointDotNormalHalf, shininess ), 0.0 );",
        // 2.0 => 2.0001 is hack to work around ANGLE bug
        "		float specularNormalization = ( shininess + 2.0001 ) / 8.0;",
        "		vec3 schlick = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( lVector, pointHalfVector ), 0.0 ), 5.0 );",
        "		pointSpecular += schlick * pointLightColor[ i ] * pointSpecularWeight * pointDiffuseWeight * lDistance * specularNormalization;",
        "	}",
        "#endif",
        "#if MAX_SPOT_LIGHTS > 0",
        "	vec3 spotDiffuse  = vec3( 0.0 );",
        "	vec3 spotSpecular = vec3( 0.0 );",
        "	for ( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {",
        "		vec4 lPosition = viewMatrix * vec4( spotLightPosition[ i ], 1.0 );",
        "		vec3 lVector = lPosition.xyz + vViewPosition.xyz;",
        "		float lDistance = 1.0;",
        "		if ( spotLightDistance[ i ] > 0.0 )",
        "			lDistance = 1.0 - min( ( length( lVector ) / spotLightDistance[ i ] ), 1.0 );",
        "		lVector = normalize( lVector );",
        "		float spotEffect = dot( spotLightDirection[ i ], normalize( spotLightPosition[ i ] - vWorldPosition ) );",
        "		if ( spotEffect > spotLightAngleCos[ i ] ) {",
        "			spotEffect = max( pow( spotEffect, spotLightExponent[ i ] ), 0.0 );",
        // diffuse

        "			float dotProduct = dot( normal, lVector );",
        "			#ifdef WRAP_AROUND",
        "				float spotDiffuseWeightFull = max( dotProduct, 0.0 );",
        "				float spotDiffuseWeightHalf = max( 0.5 * dotProduct + 0.5, 0.0 );",
        "				vec3 spotDiffuseWeight = mix( vec3( spotDiffuseWeightFull ), vec3( spotDiffuseWeightHalf ), wrapRGB );",
        "			#else",
        "				float spotDiffuseWeight = max( dotProduct, 0.0 );",
        "			#endif",
        "			spotDiffuse += diffuse * spotLightColor[ i ] * spotDiffuseWeight * lDistance * spotEffect;",
        // specular

        "			vec3 spotHalfVector = normalize( lVector + viewPosition );",
        "			float spotDotNormalHalf = max( dot( normal, spotHalfVector ), 0.0 );",
        "			float spotSpecularWeight = specularStrength * max( pow( spotDotNormalHalf, shininess ), 0.0 );",
        // 2.0 => 2.0001 is hack to work around ANGLE bug

        "			float specularNormalization = ( shininess + 2.0001 ) / 8.0;",
        "			vec3 schlick = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( lVector, spotHalfVector ), 0.0 ), 5.0 );",
        "			spotSpecular += schlick * spotLightColor[ i ] * spotSpecularWeight * spotDiffuseWeight * lDistance * specularNormalization * spotEffect;",
        "		}",
        "	}",
        "#endif",
        "#if MAX_DIR_LIGHTS > 0",
        "	vec3 dirDiffuse  = vec3( 0.0 );",
        "	vec3 dirSpecular = vec3( 0.0 );",
        "	for( int i = 0; i < MAX_DIR_LIGHTS; i ++ ) {",
        "		vec4 lDirection = viewMatrix * vec4( directionalLightDirection[ i ], 0.0 );",
        "		vec3 dirVector = normalize( lDirection.xyz );",
        // diffuse

        "		float dotProduct = dot( normal, dirVector );",
        "		#ifdef WRAP_AROUND",
        "			float dirDiffuseWeightFull = max( dotProduct, 0.0 );",
        "			float dirDiffuseWeightHalf = max( 0.5 * dotProduct + 0.5, 0.0 );",
        "			vec3 dirDiffuseWeight = mix( vec3( dirDiffuseWeightFull ), vec3( dirDiffuseWeightHalf ), wrapRGB );",
        "		#else",
        "			float dirDiffuseWeight = max( dotProduct, 0.0 );",
        "		#endif",
        "		dirDiffuse  += diffuse * directionalLightColor[ i ] * dirDiffuseWeight;",
        // specular

        "		vec3 dirHalfVector = normalize( dirVector + viewPosition );",
        "		float dirDotNormalHalf = max( dot( normal, dirHalfVector ), 0.0 );",
        "		float dirSpecularWeight = specularStrength * max( pow( dirDotNormalHalf, shininess ), 0.0 );",
        /*
         // fresnel term from skin shader
         "		const float F0 = 0.128;",

         "		float base = 1.0 - dot( viewPosition, dirHalfVector );",
         "		float exponential = pow( base, 5.0 );",

         "		float fresnel = exponential + F0 * ( 1.0 - exponential );",
         */

        /*
         // fresnel term from fresnel shader
         "		const float mFresnelBias = 0.08;",
         "		const float mFresnelScale = 0.3;",
         "		const float mFresnelPower = 5.0;",

         "		float fresnel = mFresnelBias + mFresnelScale * pow( 1.0 + dot( normalize( -viewPosition ), normal ), mFresnelPower );",
         */

        // 2.0 => 2.0001 is hack to work around ANGLE bug

        "		float specularNormalization = ( shininess + 2.0001 ) / 8.0;",
        //"dirSpecular += specular * directionalLightColor[ i ] * dirSpecularWeight * dirDiffuseWeight * specularNormalization * fresnel;",

        "		vec3 schlick = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( dirVector, dirHalfVector ), 0.0 ), 5.0 );",
        "		dirSpecular += schlick * directionalLightColor[ i ] * dirSpecularWeight * dirDiffuseWeight * specularNormalization;",
        "	}",
        "#endif",
        "#if MAX_HEMI_LIGHTS > 0",
        "	vec3 hemiDiffuse  = vec3( 0.0 );",
        "	vec3 hemiSpecular = vec3( 0.0 );",
        "	for( int i = 0; i < MAX_HEMI_LIGHTS; i ++ ) {",
        "		vec4 lDirection = viewMatrix * vec4( hemisphereLightDirection[ i ], 0.0 );",
        "		vec3 lVector = normalize( lDirection.xyz );",
        // diffuse

        "		float dotProduct = dot( normal, lVector );",
        "		float hemiDiffuseWeight = 0.5 * dotProduct + 0.5;",
        "		vec3 hemiColor = mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeight );",
        "		hemiDiffuse += diffuse * hemiColor;",
        // specular (sky light)

        "		vec3 hemiHalfVectorSky = normalize( lVector + viewPosition );",
        "		float hemiDotNormalHalfSky = 0.5 * dot( normal, hemiHalfVectorSky ) + 0.5;",
        "		float hemiSpecularWeightSky = specularStrength * max( pow( hemiDotNormalHalfSky, shininess ), 0.0 );",
        // specular (ground light)

        "		vec3 lVectorGround = -lVector;",
        "		vec3 hemiHalfVectorGround = normalize( lVectorGround + viewPosition );",
        "		float hemiDotNormalHalfGround = 0.5 * dot( normal, hemiHalfVectorGround ) + 0.5;",
        "		float hemiSpecularWeightGround = specularStrength * max( pow( hemiDotNormalHalfGround, shininess ), 0.0 );",
        "		float dotProductGround = dot( normal, lVectorGround );",
        // 2.0 => 2.0001 is hack to work around ANGLE bug

        "		float specularNormalization = ( shininess + 2.0001 ) / 8.0;",
        "		vec3 schlickSky = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( lVector, hemiHalfVectorSky ), 0.0 ), 5.0 );",
        "		vec3 schlickGround = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( lVectorGround, hemiHalfVectorGround ), 0.0 ), 5.0 );",
        "		hemiSpecular += hemiColor * specularNormalization * ( schlickSky * hemiSpecularWeightSky * max( dotProduct, 0.0 ) + schlickGround * hemiSpecularWeightGround * max( dotProductGround, 0.0 ) );",
        "	}",
        "#endif",
        "vec3 totalDiffuse = vec3( 0.0 );",
        "vec3 totalSpecular = vec3( 0.0 );",
        "#if MAX_DIR_LIGHTS > 0",
        "	totalDiffuse += dirDiffuse;",
        "	totalSpecular += dirSpecular;",
        "#endif",
        "#if MAX_HEMI_LIGHTS > 0",
        "	totalDiffuse += hemiDiffuse;",
        "	totalSpecular += hemiSpecular;",
        "#endif",
        "#if MAX_POINT_LIGHTS > 0",
        "	totalDiffuse += pointDiffuse;",
        "	totalSpecular += pointSpecular;",
        "#endif",
        "#if MAX_SPOT_LIGHTS > 0",
        "	totalDiffuse += spotDiffuse;",
        "	totalSpecular += spotSpecular;",
        "#endif",
        "	gl_FragColor.xyz = gl_FragColor.xyz * ( emissive + totalDiffuse + ambientLightColor * ambient + totalSpecular );"

    ].join("\n");
    THREE.phongDeformed = {
        ambient: 0x424242,
        color: 0x383838,
        specular: 0x595959,
        shininess: 30,
        shading: THREE.FlatShading,
        lighting: true,
        uniforms: THREE.UniformsUtils.merge([
            THREE.UniformsLib[ "common" ],
            THREE.UniformsLib[ "bump" ],
            THREE.UniformsLib[ "normalmap" ],
            THREE.UniformsLib[ "fog" ],
            THREE.UniformsLib[ "lights" ],
            THREE.UniformsLib[ "shadowmap" ],
            {
                "ambient": {type: "c", value: new THREE.Color(0xffffff)},
                "emissive": {type: "c", value: new THREE.Color(0x000000)},
                "specular": {type: "c", value: new THREE.Color(0x111111)},
                "shininess": {type: "f", value: 50},
                "wrapRGB": {type: "v3", value: new THREE.Vector3(1, 1, 1)},
                "time": {type: "f", value: 0.0},
                "depthSize": {type: "f", value: 32.0}
            }

        ]),
        vertexShader: [
            "#define PHONG",
            "uniform float time;",
            "varying vec3 vMovement;",
            "varying vec2 vUv;",
            "varying vec3 vWorldPosition;",
            "varying vec3 vViewPosition;",
            "uniform float depthSize;",
            "varying vec3 vPosition;",
            "varying vec3 vNormal;",
            THREE.ShaderChunk[ "map_pars_vertex" ],
            THREE.ShaderChunk[ "lightmap_pars_vertex" ],
            THREE.ShaderChunk[ "envmap_pars_vertex" ],
            THREE.ShaderChunk[ "lights_phong_pars_vertex" ],
            THREE.ShaderChunk[ "color_pars_vertex" ],
            THREE.ShaderChunk[ "shadowmap_pars_vertex" ],
            THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],
            pnoiseChunk,
            "void main() {",
            THREE.ShaderChunk[ "map_vertex" ],
            THREE.ShaderChunk[ "lightmap_vertex" ],
            THREE.ShaderChunk[ "color_vertex" ],
            THREE.ShaderChunk[ "defaultnormal_vertex" ],
            "	vNormal = normalize( transformedNormal );",
            vertexDeformChunk,
            THREE.ShaderChunk[ "logdepthbuf_vertex" ],
            "	vViewPosition = -mvPosition.xyz;",
            THREE.ShaderChunk[ "worldpos_vertex" ],
            THREE.ShaderChunk[ "envmap_vertex" ],
            THREE.ShaderChunk[ "lights_phong_vertex" ],
            THREE.ShaderChunk[ "shadowmap_vertex" ],
            "}"

        ].join("\n"),
        fragmentShader: [
            "#extension GL_OES_standard_derivatives : enable",
            "uniform vec3 diffuse;",
            "uniform float opacity;",
            "uniform vec3 ambient;",
            "uniform vec3 emissive;",
            "uniform vec3 specular;",
            "uniform float shininess;",
            "varying vec3 vMovement;",
            "varying vec2 vUv;",
            "varying vec3 vPosition;",
            THREE.ShaderChunk[ "color_pars_fragment" ],
            THREE.ShaderChunk[ "map_pars_fragment" ],
            THREE.ShaderChunk[ "lightmap_pars_fragment" ],
            THREE.ShaderChunk[ "envmap_pars_fragment" ],
            THREE.ShaderChunk[ "fog_pars_fragment" ],
            THREE.ShaderChunk[ "lights_phong_pars_fragment" ],
            THREE.ShaderChunk[ "shadowmap_pars_fragment" ],
            THREE.ShaderChunk["bumpmap_pars_fragment"],
            THREE.ShaderChunk[ "normalmap_pars_fragment" ],
            THREE.ShaderChunk[ "specularmap_pars_fragment" ],
            THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],
            "void main() {",
            "	gl_FragColor = vec4( vec3( 1.0 ), opacity );",
            THREE.ShaderChunk[ "logdepthbuf_fragment" ],
            THREE.ShaderChunk[ "map_fragment" ],
            THREE.ShaderChunk[ "alphatest_fragment" ],
            THREE.ShaderChunk[ "specularmap_fragment" ],
            phongDeformChunk,
            //THREE.ShaderChunk[ "lights_phong_fragment" ],
            THREE.ShaderChunk[ "lightmap_fragment" ],
            THREE.ShaderChunk[ "color_fragment" ],
            THREE.ShaderChunk[ "envmap_fragment" ],
            THREE.ShaderChunk[ "shadowmap_fragment" ],
            THREE.ShaderChunk[ "linear_to_gamma_fragment" ],
            THREE.ShaderChunk[ "fog_fragment" ],
            "}"
        ].join("\n")
    };
})();

var scene, camera, renderer, resizer, container, floorMaterial, controls, clock, gui, params;

start();
draw();
animate();

function start() {
    //Scene Start
    scene = new THREE.Scene();

    //Camera
    //I want to change this so that it maintains a 16/9 aspect ratio
    //and just scales according to changes to the view.
    var
        VIEW_ANGLE = 15,
        NEAR = 0.1,
        FAR = 10000,
        SCREEN_WIDTH = window.innerWidth,
        SCREEN_HEIGHT = window.innerHeight,
        ASPECT = SCREEN_WIDTH / SCREEN_HEIGHT;

    camera = new THREE.PerspectiveCamera(VIEW_ANGLE, ASPECT, NEAR, FAR);
    scene.add(camera);
    camera.position.set(7.763009948280866, -206.2902265242594, 127.28693819729472);
    camera.rotation.set(1.0179498946583385, 0.032014713635294394, -0.051829987432790894);
    camera.lookAt(scene.position);

    //Renderer
    renderer = new THREE.WebGLRenderer({
        antialias: true,
        alpha: true
    });

    renderer.setClearColor(0xffffff, 1.0);
    renderer.setSize(SCREEN_WIDTH, SCREEN_HEIGHT);
    resizer = new THREE.WindowResizer(renderer, camera, 1.6);
    resizer.trigger();
    container = document.getElementById('threejs');
    container.appendChild(renderer.domElement);

    clock = new THREE.Clock();

    params = {
        curTime: 0.0,
        addTime: true
    };

}

/**
 * Draw scene objects.
 */

function draw() {

    var ambientLight = new THREE.AmbientLight(0xcccccc);
    scene.add(ambientLight);
    var pointLight = new THREE.PointLight(0xffffff);
    pointLight.position.set(14.0, 84.0, 200.0);
    scene.add(pointLight);

    var phongDeformed = THREE.phongDeformed;
    phongDeformed.uniforms["pointLightPosition"] = {
        type: "v3",
        value: pointLight.position
    };
    phongDeformed.uniforms["pointLightColor"] = {
        type: "c",
        value: new THREE.Color(pointLight.color)
    };
    phongDeformed.uniforms["ambientLightColor"] = {
        type: "c",
        value: new THREE.Color(ambientLight.color)
    };
    phongDeformed.uniforms["time"] = {
        type: "f",
        value: 0.0
    };

    floorMaterial = new THREE.ShaderMaterial(phongDeformed);

    var floorGeometry = new THREE.PlaneGeometry(256, 256, 16, 16);
    var floor = new THREE.Mesh(floorGeometry, floorMaterial);
    floor.position.y = 64;
    scene.add(floor);
}

function animate() {
    requestAnimationFrame(animate);
    renderer.render(scene, camera);
    if (params.addTime) {
        params.curTime += clock.getDelta();
    }
    floorMaterial.uniforms['time'].value = 0.02 * params.curTime;
}